<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì˜¤ëŠ˜ì˜ ë‚ ì”¨ - ë³´ë“œê²Œì„</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --card-sun: #ff9f43;
            --card-rain: #54a0ff;
            --card-wind: #1dd1a1;
            --card-lightning: #5f27cd;
            --card-hybrid: #ff6b6b;
        }

        body {
            font-family: 'Pretendard', 'Malgun Gothic', sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #scaler {
            transform-origin: center center;
            transition: transform 0.2s;
        }

        /* === ì‹œì‘ í™”ë©´ === */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; z-index: 200;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            border: 5px solid #000;
        }
        .title-box {
            font-size: 48px; font-weight: bold; margin-bottom: 40px;
            text-shadow: 3px 3px 0px #aaa;
        }
        .menu-btn {
            width: 200px; padding: 15px; margin: 10px;
            font-size: 18px; font-weight: bold;
            background: white; border: 2px solid black;
            cursor: pointer; box-shadow: 4px 4px 0px #000;
            transition: transform 0.1s;
        }
        .menu-btn:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0px #000; }
        .footer { margin-top: 50px; font-size: 12px; color: #666; }

        /* === ê²Œì„ ì»¨í…Œì´ë„ˆ === */
        #game-container {
            width: 900px; height: 600px;
            background: white; border: 2px solid #000;
            display: grid;
            grid-template-columns: 1fr 300px;
            grid-template-rows: 60px 1fr 140px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            position: relative; display: none;
        }

        header {
            grid-column: 1 / -1; border-bottom: 2px solid #000;
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 20px; background: #eee; font-weight: bold;
        }

        #board-area {
            grid-column: 1 / 2; grid-row: 2 / 3;
            position: relative; background-color: #fff;
            padding: 20px; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
        }

        #status-display {
            position: absolute; top: 10px; right: 10px;
            width: 80px; height: 100px;
            border: 2px solid #333; border-radius: 8px;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            font-size: 12px; text-align: center;
            background: #dfe6e9; box-shadow: 2px 2px 0px #000;
        }
        #status-icon { font-size: 30px; margin-bottom: 5px; }

        #play-zone {
            width: 100%; height: 300px;
            background: rgba(255, 234, 167, 0.3);
            border: 2px dashed #b2bec3; border-radius: 10px;
            display: flex; justify-content: center; align-items: center;
            gap: 40px; position: relative;
        }

        /* ì¹´ë“œ */
        .card {
            width: 70px; height: 100px;
            border: 2px solid #000; border-radius: 5px;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            font-weight: bold; font-size: 12px;
            cursor: pointer; transition: transform 0.2s;
            background: white; box-shadow: 3px 3px 0px rgba(0,0,0,0.2);
            position: relative; z-index: 10;
        }
        .card:hover { transform: translateY(-5px); }
        .card.selected { border: 3px solid red; transform: translateY(-10px); }
        .card-face { font-size: 24px; margin-bottom: 5px; }
        .card-name { font-size: 10px; text-align: center; word-break: keep-all;}
        .card-sub { font-size: 10px; color: #fff; background: rgba(0,0,0,0.5); padding: 2px; border-radius: 4px; margin-top: 2px; }
        .card.back { background: #636e72; color: #b2bec3; }
        .card.back .card-face { content: "â“"; }

        .type-sun { background: var(--card-sun); color: white; }
        .type-rain { background: var(--card-rain); color: white; }
        .type-wind { background: var(--card-wind); color: white; }
        .type-lightning { background: var(--card-lightning); color: white; }
        .type-hybrid { background: var(--card-hybrid); color: white; }

        /* ë³€í™˜ ë°°ì§€ (ë³µí•© ì¹´ë“œìš©) */
        .convert-badge {
            position: absolute; top: -10px; right: -10px;
            background: #2d3436; color: #fff;
            font-size: 10px; padding: 3px 6px; border-radius: 10px;
            border: 1px solid #fff; box-shadow: 2px 2px 0 rgba(0,0,0,0.3);
            z-index: 20; white-space: nowrap;
        }

        /* ë´‡ ìŠ¬ë¡¯ */
        .bot-card-slot {
            display: flex; flex-direction: column; align-items: center;
            font-size: 12px; font-weight: bold; position: relative;
            width: 80px;
        }

        /* ì±„íŒ… ìŠ¤íƒ */
        .chat-stack {
            position: absolute; bottom: 115px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column-reverse;
            align-items: center; width: 250px; height: 150px;
            pointer-events: none; overflow: hidden; z-index: 50;
        }
        .chat-bubble {
            background: white; border: 2px solid black;
            padding: 5px 10px; border-radius: 15px;
            font-weight: bold; font-size: 12px;
            box-shadow: 2px 2px 0px rgba(0,0,0,0.2);
            margin-bottom: 5px; animation: popUp 0.3s ease-out;
            white-space: nowrap; pointer-events: auto;
        }
        .chat-sender { font-size: 10px; color: #666; margin-right: 5px; }
        @keyframes popUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* ë¦¬ë” ë§í’ì„  */
        #leader-bubble {
            position: absolute; top: -40px;
            background: #fff700; border: 2px solid black;
            padding: 8px 15px; border-radius: 20px;
            font-weight: bold; box-shadow: 3px 3px 0px rgba(0,0,0,0.2);
            z-index: 20;
        }

        /* ë¡œê·¸ */
        #log-area {
            grid-column: 2 / 3; grid-row: 2 / 4;
            border-left: 2px solid #000; background: #2d3436;
            color: #dfe6e9; padding: 10px; overflow-y: auto;
            font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.4;
        }
        .log-entry { margin-bottom: 5px; border-bottom: 1px solid #444; padding-bottom: 2px; }
        .log-turn { color: #ffeaa7; font-weight: bold; margin-top: 10px; border-top: 1px dashed #666; padding-top:5px; }
        .log-system { color: #81ecec; }
        .log-danger { color: #ff7675; font-weight: bold; }
        .log-success { color: #55efc4; font-weight: bold; }

        /* í”Œë ˆì´ì–´ ì˜ì—­ */
        #player-area {
            grid-column: 1 / 2; grid-row: 3 / 4;
            border-top: 2px solid #000;
            display: flex; flex-direction: column;
            justify-content: center; padding: 10px 20px;
            background: #fff; position: relative;
        }
        #hand-container { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        #my-hand { display: flex; gap: 10px; }
        #controls { display: flex; gap: 10px; }
        
        #emote-bar { display: flex; gap: 5px; margin-bottom: 5px; }
        .emote-btn {
            background: none; border: 1px solid #ccc; cursor: pointer;
            font-size: 16px; padding: 2px 5px; border-radius: 5px;
        }
        .emote-btn:hover { background: #eee; }

        button {
            padding: 10px 20px; border: 2px solid #000;
            background: #fff; font-weight: bold; cursor: pointer;
            box-shadow: 2px 2px 0px #000;
        }
        button:active { transform: translate(2px, 2px); box-shadow: none; }
        button:disabled { background: #ccc; color: #666; cursor: not-allowed; box-shadow: none; }

        /* ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .shake-screen { animation: shake 0.5s; background-color: rgba(255, 0, 0, 0.1) !important; }

        /* ëª¨ë‹¬ */
        #modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); display: none;
            justify-content: center; align-items: center; z-index: 100;
        }
        #modal-box {
            background: white; padding: 20px; border: 2px solid black;
            text-align: center; width: 300px; box-shadow: 5px 5px 0px #000;
        }
        .choice-btn { margin: 5px; padding: 8px 15px; cursor: pointer; }

        /* íŠœí† ë¦¬ì–¼ ì˜¤ë²„ë ˆì´ */
        #tutorial-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 150;
            display: none; pointer-events: none;
        }
        #tutorial-msg {
            position: absolute; background: white; border: 2px solid red;
            padding: 15px; border-radius: 10px; font-weight: bold;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
            pointer-events: auto; max-width: 300px; text-align: center;
        }
        .highlight { z-index: 160; position: relative; box-shadow: 0 0 15px yellow; background: rgba(255,255,255,0.9); }

    </style>
</head>
<body>

<div id="scaler">
    <div id="start-screen">
        <div class="title-box">ğŸŒ¤ï¸ ì˜¤ëŠ˜ì˜ ë‚ ì”¨</div>
        <button class="menu-btn" onclick="startGame()">ê²Œì„ ì‹œì‘</button>
        <button class="menu-btn" onclick="startTutorial()">ê²Œì„ ë°°ìš°ê¸°</button>
        <div class="footer">ì œì‘ì : gunlee41@kakao.com</div>
    </div>

    <div id="game-container">
        <header>
            <div>ì˜¤ëŠ˜ì˜ ë‚ ì”¨ ğŸŒ¤ï¸</div>
            <div id="round-info">Round 1 / 4</div>
            <div id="score-info">ë‚˜: 0 | ë´‡1: 0 | ë´‡2: 0 | ë´‡3: 0</div>
        </header>

        <div id="board-area">
            <div id="status-display">
                <div id="status-icon">ğŸ˜</div>
                <div id="status-text">í‰ì˜¨</div>
                <div id="status-desc" style="font-size:9px; color:#666;">íš¨ê³¼ ì—†ìŒ</div>
            </div>

            <div id="play-zone">
                <div class="bot-card-slot" id="slot-bot1">
                    <div class="chat-stack" id="chat-bot1"></div>
                    <span>Bot 1</span><div class="card back"></div>
                </div>
                <div class="bot-card-slot" id="slot-bot2">
                    <div class="chat-stack" id="chat-bot2"></div>
                    <span>Bot 2</span><div class="card back"></div>
                </div>
                <div class="bot-card-slot" id="slot-bot3">
                    <div class="chat-stack" id="chat-bot3"></div>
                    <span>Bot 3</span><div class="card back"></div>
                </div>
                <div id="leader-bubble" style="display:none;"></div>
            </div>
            <div id="center-message" style="margin-top: 10px; font-weight:bold; color:#d63031; height: 20px;"></div>
        </div>

        <div id="log-area"></div>

        <div id="player-area">
            <div class="chat-stack" id="chat-me" style="bottom: 100%; left: 50%; transform: translateX(-50%);"></div>

            <div id="emote-bar">
                <button class="emote-btn" onclick="sendEmote(0, 'ğŸ˜€')">ğŸ˜€</button>
                <button class="emote-btn" onclick="sendEmote(0, 'ğŸ¤”')">ğŸ¤”</button>
                <button class="emote-btn" onclick="sendEmote(0, 'ğŸ˜±')">ğŸ˜±</button>
                <button class="emote-btn" onclick="sendEmote(0, 'ğŸ˜¡')">ğŸ˜¡</button>
                <button class="emote-btn" onclick="sendEmote(0, 'ğŸ‘')">ğŸ‘</button>
            </div>
            <div id="hand-container">
                <div id="my-hand"></div>
                <div id="controls">
                    <button id="btn-submit" onclick="submitCard()">ì¹´ë“œ ë‚´ê¸°</button>
                    <button id="btn-next" onclick="nextPhase()" disabled>ë‹¤ìŒ</button>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="modal-overlay">
    <div id="modal-box">
        <h3>ì–´ë–¤ ë‚ ì”¨ë¥¼ ì›í•´?</h3>
        <p>ë¦¬ë”ë¡œì„œ ì›í•˜ëŠ” ë‚ ì”¨ë¥¼ ì„ ì–¸í•˜ì„¸ìš”.</p>
        <div id="modal-choices"></div>
    </div>
</div>

<div id="tutorial-overlay">
    <div id="tutorial-msg"></div>
</div>

<script>
    /* === í™”ë©´ ìŠ¤ì¼€ì¼ë§ === */
    function resizeGame() {
        const scaler = document.getElementById('scaler');
        const scale = Math.min(window.innerWidth / 900, window.innerHeight / 600, 1);
        scaler.style.transform = `scale(${scale})`;
    }
    window.addEventListener('resize', resizeGame);
    window.addEventListener('load', resizeGame);

    /* === ì‚¬ìš´ë“œ === */
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const SFX = {
        CLICK: () => playTone(800, 'sine', 0.05),
        CARD: () => playTone(400, 'triangle', 0.1),
        WIN: () => { playTone(523, 'sine', 0.1); setTimeout(()=>playTone(659, 'sine', 0.1), 100); setTimeout(()=>playTone(784, 'sine', 0.2), 200); },
        LOSE: () => { playTone(300, 'sawtooth', 0.2); setTimeout(()=>playTone(200, 'sawtooth', 0.4), 200); },
        LIGHTNING: () => { playNoise(0.5); }
    };

    function playTone(freq, type, duration) {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
        osc.stop(audioCtx.currentTime + duration);
    }

    function playNoise(duration) {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const bufferSize = audioCtx.sampleRate * duration;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const gain = audioCtx.createGain();
        gain.gain.value = 0.5;
        noise.connect(gain);
        gain.connect(audioCtx.destination);
        noise.start();
    }

    /* === ë°ì´í„° === */
    const CARD_TYPES = {
        SUN: { name: 'í•´', icon: 'â˜€ï¸', color: 'type-sun' },
        RAIN: { name: 'ë¹„', icon: 'â˜”', color: 'type-rain' },
        WIND: { name: 'ë°”ëŒ', icon: 'ğŸƒ', color: 'type-wind' },
        LIGHTNING: { name: 'ë²ˆê°œ', icon: 'âš¡', color: 'type-lightning' },
        HYBRID: { name: 'ë³µí•©', icon: 'ğŸŒˆ', color: 'type-hybrid' }
    };

    const STATUS_EFFECTS = {
        NORMAL: { name: 'í‰ì˜¨', icon: 'ğŸ˜', desc: 'íš¨ê³¼ ì—†ìŒ' },
        HOT: { name: 'ë”ì›Œ', icon: 'ğŸ¥µ', desc: 'ë°”ëŒ ìŠ¹ë¦¬ ì‹œ +1ì ' },
        HUMID: { name: 'ìŠµí•´', icon: 'ğŸ’§', desc: 'í•´ ìŠ¹ë¦¬ ì‹œ +1ì ' },
        COLD: { name: 'ì¶”ì›Œ', icon: 'ğŸ¥¶', desc: 'í•´ ìŠ¹ë¦¬ ì‹œ +1ì ' },
        SCARY: { name: 'ë¬´ì„œì›Œ', icon: 'ğŸ˜±', desc: 'ìŠ¹ë¦¬ì ì „ì› +1ì ' }
    };

    const FULL_DECK_TEMPLATE = [
        ...Array(4).fill({ type: 'SUN', name: 'í•´' }),
        ...Array(4).fill({ type: 'RAIN', name: 'ë¹„' }),
        ...Array(4).fill({ type: 'WIND', name: 'ë°”ëŒ' }),
        { type: 'HYBRID', subType: ['SUN', 'RAIN'], name: 'ì—¬ìš°ë¹„', unsafe: false },
        { type: 'HYBRID', subType: ['SUN', 'WIND'], name: 'ì ì ˆí•œ ì—¬ë¦„', unsafe: false },
        { type: 'HYBRID', subType: ['RAIN', 'WIND'], name: 'ë¹„ë°”ëŒ', unsafe: false },
        { type: 'HYBRID', subType: ['SUN', 'LIGHTNING'], name: 'ë§ˆë¥¸í•˜ëŠ˜ ë‚ ë²¼ë½', unsafe: true },
        { type: 'HYBRID', subType: ['RAIN', 'LIGHTNING'], name: 'ë‡Œìš°', unsafe: true },
        { type: 'HYBRID', subType: ['WIND', 'LIGHTNING'], name: 'ëŒí’', unsafe: true },
        ...Array(2).fill({ type: 'LIGHTNING', name: 'ë²ˆê°œ' })
    ];

    let gameState = {
        mode: 'TITLE',
        round: 1, maxRounds: 4, // 4ë¼ìš´ë“œë¡œ ìˆ˜ì • (ëª¨ë‘ í•œ ë²ˆì”© ë¦¬ë”)
        players: [],
        leaderIndex: 0,
        currentStatus: 'NORMAL',
        playedCards: [],
        phase: 'READY',
        deck: [],
        leaderReq: null
    };

    let selectedHandIndex = -1;
    let tutorialStep = 0;
    let botTimer = null;

    /* === ì´ˆê¸°í™” === */
    function startGame() {
        SFX.CLICK();
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('game-container').style.display = 'grid';
        resizeGame();
        gameState.mode = 'GAME';
        gameState.round = 1;
        gameState.maxRounds = 4; // 4ë¼ìš´ë“œ ì„¤ì •
        gameState.currentStatus = 'NORMAL';
        
        gameState.players = [
            { id: 0, name: 'ë‚˜', isBot: false, hand: [], score: 0 },
            { id: 1, name: 'ë´‡1', isBot: true, hand: [], score: 0 },
            { id: 2, name: 'ë´‡2', isBot: true, hand: [], score: 0 },
            { id: 3, name: 'ë´‡3', isBot: true, hand: [], score: 0 }
        ];
        
        log("ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.", "system");
        startRound();
    }

    function startTutorial() {
        SFX.CLICK();
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('game-container').style.display = 'grid';
        resizeGame();
        gameState.mode = 'TUTORIAL';
        
        gameState.players = [
            { id: 0, name: 'ë‚˜', isBot: false, hand: [], score: 0 },
            { id: 1, name: 'ë´‡1', isBot: true, hand: [], score: 0 },
            { id: 2, name: 'ë´‡2', isBot: true, hand: [], score: 0 },
            { id: 3, name: 'ë´‡3', isBot: true, hand: [], score: 0 }
        ];
        
        runTutorial();
    }

    function shuffle(array) { return array.sort(() => Math.random() - 0.5); }
    function createDeck() { return shuffle(JSON.parse(JSON.stringify(FULL_DECK_TEMPLATE))); }
    
    function log(msg, type = '') {
        const logArea = document.getElementById('log-area');
        const div = document.createElement('div');
        div.className = `log-entry log-${type}`;
        div.innerText = msg;
        logArea.appendChild(div);
        logArea.scrollTop = logArea.scrollHeight;
    }

    /* === UI ì—…ë°ì´íŠ¸ === */
    function updateUI() {
        document.getElementById('round-info').innerText = `Round ${gameState.round} / ${gameState.maxRounds}`;
        let scoreText = gameState.players.map(p => `${p.name}: ${p.score}`).join(' | ');
        document.getElementById('score-info').innerText = scoreText;

        const status = STATUS_EFFECTS[gameState.currentStatus];
        document.getElementById('status-icon').innerText = status.icon;
        document.getElementById('status-text').innerText = status.name;
        document.getElementById('status-desc').innerText = status.desc;

        const handDiv = document.getElementById('my-hand');
        handDiv.innerHTML = '';
        gameState.players[0].hand.forEach((card, idx) => {
            const cardEl = createCardElement(card);
            if (idx === selectedHandIndex) cardEl.classList.add('selected');
            cardEl.onclick = () => {
                SFX.CLICK();
                if (gameState.phase === 'LEADER_ACT' || gameState.phase === 'FOLLOWER_ACT') {
                    selectedHandIndex = idx;
                    updateUI();
                }
            };
            handDiv.appendChild(cardEl);
        });

        const submitBtn = document.getElementById('btn-submit');
        const nextBtn = document.getElementById('btn-next');
        
        if (gameState.phase === 'LEADER_ACT' && gameState.players[gameState.leaderIndex].id === 0) {
            submitBtn.disabled = false;
            submitBtn.innerText = "ë¦¬ë”: ì¹´ë“œ ë‚´ê¸°";
        } else if (gameState.phase === 'FOLLOWER_ACT' && !hasPlayerPlayed(0)) {
            submitBtn.disabled = false;
            submitBtn.innerText = "ì¹´ë“œ ë‚´ê¸°";
        } else {
            submitBtn.disabled = true;
        }

        nextBtn.disabled = (gameState.phase !== 'RESOLVE');
        if(gameState.phase === 'RESOLVE') {
            nextBtn.innerText = "ë‹¤ìŒ ë¼ìš´ë“œ";
            nextBtn.onclick = nextPhase;
        }
    }

    function createCardElement(card, isBack = false, effectiveType = null) {
        const div = document.createElement('div');
        div.className = `card ${isBack ? 'back' : ''} ${!isBack ? CARD_TYPES[card.type].color : ''}`;
        
        if (!isBack) {
            const icon = document.createElement('div');
            icon.className = 'card-face';
            icon.innerText = CARD_TYPES[card.type].icon;
            
            const name = document.createElement('div');
            name.className = 'card-name';
            name.innerText = card.name;
            div.appendChild(icon);
            div.appendChild(name);

            if (card.type === 'HYBRID') {
                const sub = document.createElement('div');
                sub.className = 'card-sub';
                sub.innerText = `${CARD_TYPES[card.subType[0]].icon}+${CARD_TYPES[card.subType[1]].icon}`;
                div.appendChild(sub);
            }

            if (effectiveType && effectiveType !== card.type) {
                const badge = document.createElement('div');
                badge.className = 'convert-badge';
                badge.innerText = `${CARD_TYPES[effectiveType].icon}ë¡œ ë³€í™˜ë¨`;
                div.appendChild(badge);
            }
        } else {
            const icon = document.createElement('div');
            icon.className = 'card-face';
            icon.innerText = "â“";
            div.appendChild(icon);
        }
        return div;
    }

    function hasPlayerPlayed(pid) { return gameState.playedCards.some(pc => pc.playerId === pid); }

    /* === ì´ëª¨ì§€ ì‹œìŠ¤í…œ === */
    function sendEmote(pid, emoji) {
        if (pid === 0) {
            SFX.CLICK();
            setTimeout(() => botReact('THINK'), 500);
        }
        
        let stackId = pid === 0 ? 'chat-me' : `chat-bot${pid}`;
        const stack = document.getElementById(stackId);
        
        const bubble = document.createElement('div');
        bubble.className = 'chat-bubble';
        bubble.innerHTML = `<span class="chat-sender">${gameState.players[pid].name}</span> ${emoji}`;
        
        stack.prepend(bubble);
        setTimeout(() => {
            bubble.style.opacity = '0';
            setTimeout(() => bubble.remove(), 300);
        }, 3000);
    }

    function botReact(type) {
        const emojis = {
            WIN: ['ğŸ˜€', 'ğŸ˜', 'ğŸ‰', 'ğŸŒ'],
            LOSE: ['ğŸ˜­', 'ğŸ˜¡', 'ğŸ˜±', 'â˜”'],
            LIGHTNING: ['âš¡', 'ğŸ’€', 'ğŸ¥¶', 'â›ˆï¸'],
            THINK: ['ğŸ¤”', '...', 'ğŸ‘€', 'ğŸ‘', 'ğŸ‘‹']
        };
        
        gameState.players.forEach(p => {
            if(p.isBot && Math.random() > 0.4) {
                const list = emojis[type];
                const pick = list[Math.floor(Math.random() * list.length)];
                setTimeout(() => sendEmote(p.id, pick), Math.random() * 1500);
            }
        });
    }

    /* === ê²Œì„ ë¡œì§ === */
    function startRound() {
        if(gameState.mode === 'TUTORIAL') return;
        if(botTimer) clearTimeout(botTimer);

        gameState.deck = createDeck();
        gameState.playedCards = [];
        selectedHandIndex = -1;
        
        gameState.players.forEach(p => {
            p.hand = [gameState.deck.pop(), gameState.deck.pop(), gameState.deck.pop()];
        });

        gameState.leaderIndex = (gameState.round - 1) % 4;
        const leader = gameState.players[gameState.leaderIndex];

        log(`=== Round ${gameState.round} ì‹œì‘ ===`, 'turn');
        log(`ì´ë²ˆ ë¼ìš´ë“œ ë¦¬ë”: [${leader.name}]`);

        document.querySelectorAll('.bot-card-slot .card').forEach(el => el.remove());
        document.querySelectorAll('.bot-card-slot').forEach(slot => {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'card back';
            slot.appendChild(cardDiv);
        });
        
        document.getElementById('leader-bubble').style.display = 'none';
        document.getElementById('center-message').innerText = "";

        gameState.phase = 'LEADER_ACT';
        updateUI();

        if (leader.isBot) {
            botTimer = setTimeout(botLeaderPlay, 1000);
        }
    }

    function botLeaderPlay() {
        if(gameState.phase !== 'LEADER_ACT') return;
        const bot = gameState.players[gameState.leaderIndex];
        let cardIdx = bot.hand.findIndex(c => ['SUN', 'RAIN', 'WIND'].includes(c.type));
        if (cardIdx === -1) cardIdx = 0;

        const card = bot.hand[cardIdx];
        let declareType = card.type;
        if (card.type === 'HYBRID') declareType = card.subType[0];
        if (card.type === 'LIGHTNING') declareType = 'SUN';

        playCardAction(bot.id, cardIdx, declareType);
    }

    function playCardAction(pid, cardIdx, declaredType = null) {
        SFX.CARD();
        const player = gameState.players[pid];
        const card = player.hand.splice(cardIdx, 1)[0];
        
        gameState.playedCards.push({ playerId: pid, card: card, declaredType: declaredType });

        const isLeader = (pid === gameState.leaderIndex);
        if (pid !== 0) {
            const slot = document.getElementById(`slot-bot${pid}`);
            const oldCard = slot.querySelector('.card');
            if(oldCard) oldCard.remove();
            slot.appendChild(createCardElement(card, !isLeader));
        }

        if (isLeader) {
            log(`${player.name}(ë¦¬ë”)ê°€ ì¹´ë“œë¥¼ ëƒˆìŠµë‹ˆë‹¤.`);
            showBubble(`ë‚˜ëŠ” [${CARD_TYPES[declaredType].name}] ë‚ ì”¨ê°€ ì¢‹ì•„!`);
            gameState.leaderReq = declaredType;
            gameState.phase = 'FOLLOWER_ACT';
            
            if (pid === 0) {
                botTimer = setTimeout(botsFollow, 1000);
            } else {
                botTimer = setTimeout(() => botsFollow(true), 800);
            }
        } else {
            if (gameState.playedCards.length === 4) {
                gameState.phase = 'RESOLVE';
                log("ëª¨ë“  í”Œë ˆì´ì–´ê°€ ì¹´ë“œë¥¼ ëƒˆìŠµë‹ˆë‹¤.", "system");
                updateUI();
            }
        }
        updateUI();
    }

    function showBubble(text) {
        const bubble = document.getElementById('leader-bubble');
        bubble.innerText = text;
        bubble.style.display = 'block';
    }

    function botsFollow(excludePlayer = false) {
        const botsToPlay = gameState.players.filter(p => p.isBot && p.id !== gameState.leaderIndex && !hasPlayerPlayed(p.id));
        
        let delay = 0;
        botsToPlay.forEach(bot => {
            delay += 800;
            botTimer = setTimeout(() => {
                let target = gameState.leaderReq;
                let pickIdx = bot.hand.findIndex(c => c.type === target);
                if (pickIdx === -1) pickIdx = bot.hand.findIndex(c => c.type === 'HYBRID' && c.subType.includes(target));
                if (pickIdx === -1) pickIdx = Math.floor(Math.random() * bot.hand.length);
                
                const lightningIdx = bot.hand.findIndex(c => c.type === 'LIGHTNING');
                if (lightningIdx !== -1 && Math.random() < 0.1) pickIdx = lightningIdx;

                playCardAction(bot.id, pickIdx);
            }, delay);
        });
    }

    function submitCard() {
        if (selectedHandIndex === -1) {
            alert("ë‚¼ ì¹´ë“œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.");
            return;
        }
        const myCard = gameState.players[0].hand[selectedHandIndex];

        if (gameState.phase === 'LEADER_ACT') {
            openDeclarationModal(myCard);
        } else {
            playCardAction(0, selectedHandIndex);
            
            if(gameState.mode === 'TUTORIAL' && tutorialStep === 2) {
                document.getElementById('tutorial-overlay').style.display = 'block';
                tutorialStep = 3;
                runTutorial();
                return;
            }

            botTimer = setTimeout(botsFollow, 500);
        }
    }

    function openDeclarationModal(card) {
        const modal = document.getElementById('modal-overlay');
        const choicesDiv = document.getElementById('modal-choices');
        choicesDiv.innerHTML = '';

        let options = [];
        if (card.type === 'HYBRID') options = card.subType;
        else if (card.type === 'LIGHTNING') options = ['SUN', 'RAIN', 'WIND'];
        else options = [card.type];

        options.forEach(type => {
            const btn = document.createElement('button');
            btn.className = 'choice-btn';
            btn.innerText = CARD_TYPES[type].name;
            btn.onclick = () => {
                SFX.CLICK();
                modal.style.display = 'none';
                playCardAction(0, selectedHandIndex, type);
                
                if(gameState.mode === 'TUTORIAL' && tutorialStep === 2) {
                    document.getElementById('tutorial-overlay').style.display = 'block';
                    tutorialStep = 3;
                    runTutorial();
                }
            };
            choicesDiv.appendChild(btn);
        });
        modal.style.display = 'flex';
    }

    function nextPhase() {
        SFX.CLICK();
        
        if (gameState.mode === 'TUTORIAL') {
            alert("íŠœí† ë¦¬ì–¼ì„ ë§ˆì³¤ìŠµë‹ˆë‹¤! ì´ì œ ì‹¤ì „ì…ë‹ˆë‹¤.");
            location.reload();
            return;
        }

        if (gameState.phase !== 'RESOLVE') return;

        const playZone = document.getElementById('play-zone');
        document.getElementById('leader-bubble').style.display = 'block';
        document.getElementById('leader-bubble').innerText = `ë‚˜ëŠ” [${CARD_TYPES[gameState.leaderReq].name}] ë‚ ì”¨ê°€ ì¢‹ì•„!`;

        const leaderPlay = gameState.playedCards.find(p => p.playerId === gameState.leaderIndex);
        const followersPlay = gameState.playedCards.filter(p => p.playerId !== gameState.leaderIndex);

        const result = calculateResult(leaderPlay, followersPlay);

        [leaderPlay, ...followersPlay].forEach(p => {
            if(p.playerId !== 0) {
                const slot = document.getElementById(`slot-bot${p.playerId}`);
                const oldCard = slot.querySelector('.card');
                if(oldCard) oldCard.remove();
                
                let effective = null;
                const matchInfo = result.effectiveTypes.find(e => e.pid === p.playerId);
                if(matchInfo) effective = matchInfo.type;

                slot.appendChild(createCardElement(p.card, false, effective));
            }
        });

        gameState.round++;
        if (gameState.round > gameState.maxRounds) {
            gameState.phase = 'END';
            setTimeout(endGame, 3000);
        } else {
            gameState.phase = 'READY';
            document.getElementById('btn-next').innerText = "ë‹¤ìŒ ë¼ìš´ë“œ";
            document.getElementById('btn-next').onclick = startRound;
        }
    }

    function calculateResult(leaderPlay, followersPlay) {
        const allCards = [leaderPlay, ...followersPlay];
        let msg = "";
        let winners = [];
        let scoreGain = 0;
        let nextStatus = 'NORMAL';
        let effectiveTypes = [];

        const realLightningCount = allCards.filter(p => p.card.type === 'LIGHTNING').length;
        let totalLightningCount = realLightningCount;
        if (realLightningCount > 0) {
            totalLightningCount += allCards.filter(p => p.card.unsafe).length;
        }

        if (totalLightningCount >= 2) {
            SFX.LIGHTNING();
            document.body.classList.add('shake-screen');
            setTimeout(() => document.body.classList.remove('shake-screen'), 500);
            msg = "âš¡ ì½°ê´‘! ë²ˆê°œê°€ ì³ì„œ ë‚ ì”¨ê°€ ì—‰ë§ì´ ë˜ì—ˆìŠµë‹ˆë‹¤!";
            log(msg, 'danger');
            allCards.forEach(p => {
                if (p.card.type === 'LIGHTNING' || (realLightningCount > 0 && p.card.unsafe)) {
                    gameState.players[p.playerId].score -= 1;
                }
            });
            nextStatus = 'SCARY';
            botReact('LIGHTNING');
        } else {
            const reqType = leaderPlay.declaredType;
            const leaderCardType = leaderPlay.card.type;

            if (['SUN', 'RAIN', 'WIND', 'LIGHTNING'].includes(leaderCardType)) {
                let matchCount = 1;
                let matchPlayers = [leaderPlay.playerId];
                
                followersPlay.forEach(p => {
                    let isMatch = false;
                    let eff = p.card.type;

                    if (p.card.type === reqType) isMatch = true;
                    if (p.card.type === 'HYBRID' && p.card.subType.includes(reqType)) {
                        isMatch = true;
                        eff = reqType;
                    }
                    
                    if (isMatch) { 
                        matchCount++; 
                        matchPlayers.push(p.playerId);
                        effectiveTypes.push({ pid: p.playerId, type: eff });
                    }
                });

                if (matchCount >= 3) {
                    SFX.WIN();
                    msg = `ì„±ê³µ! [${CARD_TYPES[reqType].name}] ë‚ ì”¨ê°€ ê²°ì •ë˜ì—ˆìŠµë‹ˆë‹¤.`;
                    log(msg, 'success');
                    winners = matchPlayers;
                    scoreGain = 1;
                    if (gameState.currentStatus === 'HOT' && reqType === 'WIND') scoreGain++;
                    if (gameState.currentStatus === 'HUMID' && reqType === 'SUN') scoreGain++;
                    if (gameState.currentStatus === 'COLD' && reqType === 'SUN') scoreGain++;
                    if (gameState.currentStatus === 'SCARY') scoreGain++;
                    
                    if (reqType === 'SUN') nextStatus = 'HOT';
                    if (reqType === 'RAIN') nextStatus = 'HUMID';
                    if (reqType === 'WIND') nextStatus = 'COLD';
                    botReact('WIN');
                } else {
                    SFX.LOSE();
                    msg = "ì‹¤íŒ¨... ì˜ê²¬ì´ ëª¨ì´ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.";
                    log(msg);
                    nextStatus = 'NORMAL';
                    botReact('LOSE');
                }
            } else if (leaderCardType === 'HYBRID') {
                const ingredients = leaderPlay.card.subType;
                const hasIng1 = followersPlay.some(p => p.card.type === ingredients[0] || (p.card.type === 'HYBRID' && p.card.subType.includes(ingredients[0])));
                const hasIng2 = followersPlay.some(p => p.card.type === ingredients[1] || (p.card.type === 'HYBRID' && p.card.subType.includes(ingredients[1])));

                if (hasIng1 && hasIng2) {
                    SFX.WIN();
                    msg = `ëŒ€ì„±ê³µ! í¬ê·€í•œ [${leaderPlay.card.name}]ê°€ ë‚´ë¦½ë‹ˆë‹¤!`;
                    log(msg, 'success');
                    winners = gameState.players.map(p => p.id);
                    scoreGain = 1;
                    nextStatus = 'NORMAL';
                    botReact('WIN');
                } else {
                    SFX.LOSE();
                    msg = `ì‹¤íŒ¨... ì¬ë£Œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.`;
                    log(msg);
                    nextStatus = 'NORMAL';
                    botReact('LOSE');
                }
            }
        }

        winners.forEach(pid => gameState.players[pid].score += scoreGain);
        document.getElementById('center-message').innerText = msg;
        gameState.currentStatus = nextStatus;
        updateUI();

        return { effectiveTypes };
    }

    function endGame() {
        const sorted = [...gameState.players].sort((a, b) => b.score - a.score);
        const winner = sorted[0];
        alert(`ğŸ† ìš°ìŠ¹: ${winner.name} (${winner.score}ì )\n\nê²Œì„ì„ ë‹¤ì‹œ ì‹œì‘í•©ë‹ˆë‹¤.`);
        location.reload();
    }

    /* === íŠœí† ë¦¬ì–¼ ë¡œì§ === */
    function runTutorial() {
        const overlay = document.getElementById('tutorial-overlay');
        const msgBox = document.getElementById('tutorial-msg');
        overlay.style.display = 'block';

        function showMsg(text, targetId = null, nextCallback) {
            msgBox.innerHTML = `${text}<br><br><button id='tuto-next'>ë‹¤ìŒ</button>`;
            
            if(targetId) {
                const target = document.getElementById(targetId);
                target.classList.add('highlight');
                msgBox.style.top = '50%'; msgBox.style.left = '50%';
                msgBox.style.transform = 'translate(-50%, -50%)';
            } else {
                msgBox.style.top = '50%'; msgBox.style.left = '50%';
                msgBox.style.transform = 'translate(-50%, -50%)';
            }

            document.getElementById('tuto-next').onclick = () => {
                SFX.CLICK();
                if(targetId) document.getElementById(targetId).classList.remove('highlight');
                nextCallback();
            };
        }

        if(tutorialStep === 0) {
            showMsg("í™˜ì˜í•©ë‹ˆë‹¤! ë‚ ì”¨ ìš”ì •ì´ ë˜ì–´ ìµœê³ ì˜ ë‚ ì”¨ë¥¼ ë§Œë“¤ì–´ë³´ì„¸ìš”.", null, () => {
                tutorialStep = 1;
                runTutorial();
            });
        } else if(tutorialStep === 1) {
            gameState.players[0].hand = [
                { type: 'SUN', name: 'í•´' },
                { type: 'HYBRID', subType: ['SUN', 'RAIN'], name: 'ì—¬ìš°ë¹„', unsafe: false },
                { type: 'LIGHTNING', name: 'ë²ˆê°œ' }
            ];
            updateUI();
            showMsg("ì´ê³³ì€ ë‹¹ì‹ ì˜ íŒ¨ì…ë‹ˆë‹¤.<br>ë³µí•© ì¹´ë“œëŠ” êµ¬ì„± ìš”ì†Œê°€ ì‘ê²Œ í‘œì‹œë©ë‹ˆë‹¤.", 'my-hand', () => {
                tutorialStep = 2;
                runTutorial();
            });
        } else if(tutorialStep === 2) {
            gameState.phase = 'LEADER_ACT';
            gameState.leaderIndex = 0;
            updateUI();
            overlay.style.display = 'none';
            msgBox.innerHTML = "ë‹¹ì‹ ì€ ì´ë²ˆ í„´ì˜ <b>ë¦¬ë”</b>ì…ë‹ˆë‹¤.<br>'í•´' ì¹´ë“œë¥¼ ì„ íƒí•´ì„œ ë‚´ë³´ì„¸ìš”.<br>(í™”ë©´ ì¤‘ì•™ ìƒë‹¨ì— íŒíŠ¸ê°€ ëœ¹ë‹ˆë‹¤)";
            
            const hint = document.createElement('div');
            hint.id = 'tuto-hint';
            hint.style.position = 'absolute';
            hint.style.top = '20%'; hint.style.left = '50%'; hint.style.transform = 'translateX(-50%)';
            hint.style.background = 'white'; hint.style.border = '2px solid red'; hint.style.padding = '10px';
            hint.style.zIndex = 200; hint.innerText = "ğŸ‘‡ 'í•´' ì¹´ë“œë¥¼ ëˆ„ë¥´ê³  'ì¹´ë“œ ë‚´ê¸°'ë¥¼ í´ë¦­í•˜ì„¸ìš”!";
            document.body.appendChild(hint);
        } else if(tutorialStep === 3) {
            const hint = document.getElementById('tuto-hint');
            if(hint) hint.remove();
            
            showMsg("ì˜í–ˆìŠµë‹ˆë‹¤! ë¦¬ë”ëŠ” ì›í•˜ëŠ” ë‚ ì”¨ë¥¼ ì„ ì–¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>ì´ì œ ë´‡ë“¤ì´ ì¹´ë“œë¥¼ ë‚¼ ê²ƒì…ë‹ˆë‹¤.", null, () => {
                overlay.style.display = 'none';
                setTimeout(() => {
                    playCardAction(1, 0);
                    setTimeout(() => {
                        playCardAction(2, 0);
                        setTimeout(() => {
                            playCardAction(3, 0);
                            const nextBtn = document.getElementById('btn-next');
                            nextBtn.innerText = "ê²°ê³¼ í™•ì¸ (íŠœí† ë¦¬ì–¼ ì¢…ë£Œ)";
                            nextBtn.onclick = nextPhase;
                        }, 800);
                    }, 800);
                }, 800);
            });
        }
    }

</script>

</body>
</html>